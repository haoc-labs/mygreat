#!/usr/bin/env node

'use strict'

const path = require('path')
const mygreat = require('../index')
const program = require('commander')
const ConflictError = require('../errors/conflict')
const environment = process.env.NODE_ENV || 'development'
const fallback = (value, defaultValue) => value || defaultValue

const configFactory = (dir) => {
  return require(path.resolve(process.cwd(), dir))(environment)
}

const errorHandler = (err) => {
  console.log('')

  if (err instanceof ConflictError) {
    console.error('#', 'Conflict Error')
    console.error('#', 'Unable to proceed due possible integrity break.')
    console.error('#', 'Any of the following scenarios could couse this error:')
    console.error('#', '  - a synced migration file has been renamed')
    console.error('#', '  - a new migration has been named wrongly - all new migrations should be placed as last, considering an ascending order')
    console.error('#', '  - a synced migration file has been deleted before been migrated-down')
    console.error('#', '  - migrating down should alway revert the most recent migration execution registry, otherwise the next execution could trigger this error')
    process.exit(1)
  }

  console.error('#', 'Error:', err.name)
  console.error('#', err.message)
  console.error('#', err.stack)
  process.exit(1)
}

;(async () => {
  program
    .version(process.env.npm_package_version)
    .option('-f, --file <dir>', 'path to mygreat configuration file', fallback, './.mygreat.js')

  program
    .command('up')
    .action(options => {
      const config = configFactory(options.parent.file)
      const migrate = mygreat.from(config.local, config.remote)

      console.log('Migrating up...')

      Promise
        .resolve(config.setup())
        .then(setup => migrate.up(setup))
        .then(result => {
          if (result.content.length === 0) {
            return console.log('Nothing to migrate up')
          }
          console.log('')
          console.log(`Migration id #${result.name}`)
          result.content.forEach(file => {
            console.log(`  - migration file ${file} has been migrated up`)
          })
        })
        .catch(errorHandler)
    })

  program
    .command('down')
    .action(options => {
      const config = configFactory(options.parent.file)
      const migrate = mygreat.from(config.local, config.remote)

      console.log('Migrating down...')

      Promise
        .resolve(config.setup())
        .then(setup => migrate.up(setup))
        .then(result => {
          if (!result || result.content.length === 0) {
            return console.log('Nothing to migrate down')
          }
          console.log('')
          console.log(`Migration id #${result.name}`)
          result.content.forEach(file => {
            console.log(`  - migration file ${file} has been migrated down`)
          })
        })
        .catch(errorHandler)
    })

  program.parse(process.argv)
})()

